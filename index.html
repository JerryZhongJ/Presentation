<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<title>Gradual Program Analysis for Null Pointers</title>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Gradual Program Analysis for Null Pointers</h2>
					<ul>
						<li><strong>Sam Estep</strong>
						Carnegie Mellon University, Pittsburgh, PA, USA</li>
						<li><strong>Wise</strong>
						Carnegie Mellon University, Pittsburgh, PA, USA</li> 
						<li><strong>Jonathan Aldrich</strong>
							Carnegie Mellon University, Pittsburgh, PA, USA</li>
						<li><strong>Éric Tanter</strong>
							Computer Science Department (DCC), University of Chile, Santiago, Chile</li>
						<li><strong>Johannes Bader</strong>
							Jane Street, New York, NY, USA</li>	
						<li><strong>Joshua Sunshine</strong>
							Carnegie Mellon University, Pittsburgh, PA, USA</li>
						</ul>

				</section>

				<section>
					<h2>Nullness Check</h2>
					<ul>
						<li>标记: @Nonnull, @Nullable</li>
						<li>位置：方法的参数和返回值</li>
						<li>现有工具: Facebook’s Infer Eradicate,  Uber’s
							NullAway, NullSafe, Java Nullness Checker
						</li>
						<li>当标记缺失，现有的工具会补上一个默认的标记：
							<ul>
								<li>Infer Eradicate, Java Nullness Checker: @Nonnull</li>
								<li>NullAway: 汇(sink)=@Nullable，源(sources)=@Nonnull</li>
							</ul>
						</li>
						<li>这会导致False Positive，同时是unsound的</li>
					</ul>
					<aside class="notes">
						1. Nonnull表示不应该取null值，nullable表示可以为null。一般打在。。。
						2. 假如标记是完整的，静态空指针检查工具会很有用。但是实践中往往存在可能忘打、漏打标记，尤其是依赖的第三方库它没有打标记。
						3. 此时静态检查工具会在缺失标记的地方打上默认的标记，如。。。
						4. 但这种处理方法会引入很多False Positive，同时也不能保证为sound。
					</aside>
				</section>
				<section>
					<h2>Example of False Positive</h2>
					<pre><code data-trim data-line-numbers>
						class Main {
							static      String reverse (String      str) {
								if (str == null) return new String();
								StringBuilder builder = new StringBuilder(str);
								builder.reverse();
								return builder.toString();
							}
							public static void main (String [] args) {
								String reversed = reverse(null);
							 	String frown = reverse(":)");
							 	String both = reversed.concat(frown);
							 	System.out.println(both);
							}
						}
					</code></pre>
					<ul>
						<li>Infer Eradicate, Java Nullness Checker: @NonNull</li>
						<li>行9出现警告，是FP</li>
					</ul>
					<aside class="notes">
						在这个例子中，reserve是缺失标记的方法。我们可以看到这个方法一开始就判断参数是否是null，是null就返回一个新的对象，不是null就对它进行一些操作，再把它返回回去。
						返回值永远不是null
						但是我们的静态检查工具会添加默认的标记@Nonnull，这导致传递null作为参数时会报错，但这不是这个方法的本意。
					</aside>
				</section>
				<section>
					<h2>Example of False Negative</h2>
					<pre><code>
						class Main {
							static      String reverse (String      str) {
								if (str == null) return null;
								StringBuilder builder = new StringBuilder(str);
								builder.reverse();
								return builder.toString();
							}
							public static void main (String [] args) {
								String reversed = reverse(null);
							 	String frown = reverse(":)");
							 	String both = reversed.concat(frown);
							 	System.out.println(both);
							}
						}
					</code></pre>
					<ul>
						<li>行3出现警告，是FP</li>
						<li>行11没有警告，是FN（reserved是null）</li>
					</ul>
					<aside class="notes">
						我们把第三行换成return null。这时参数还是nullable，但是返回值变成nullable。
						这时，第11行应该要报错，因为reserved可能是null，这里对空指针解引用。但是静态分析工具把方法标记为nonnull，所以识别不出来。
						因此是unsound的。
					</aside>
				</section>
				<section>
					<h2>Gradual Null Pointer Analysis</h2>
					<ul>
						<li class="fragment">不添加默认标记</li>
						<li class="fragment">乐观处理：当标记缺失而无法检查，那就不检查</li>
						<li class="fragment"> 这样必然是unsound的，因此添加动态检查</li>
						<li class="fragment">乐观的静态检查减少FP + 动态检查保证soundness</li>
					</ul>
					<div class="r-stack">
						<pre class="fragment fade-in-then-out"><code> 
							class Main {
								static      String reverse (String      str) {
									if (str == null) return new String();
									StringBuilder builder = new StringBuilder(str);
									builder.reverse();
									return builder.toString();
								}
								public static void main (String [] args) {
									String reversed = reverse(null);
									String frown = reverse(":)");
									String both = reversed.concat(frown);
									System.out.println(both);
								}
							}
						</code></pre>
						<pre class="fragment"><code>
							class Main {
								static      String reverse (String      str) {
									if (str == null) return null;
									StringBuilder builder = new StringBuilder(str);
									builder.reverse();
									return builder.toString();
								}
								public static void main (String [] args) {
									String reversed = reverse(null);
									String frown = reverse(":)");
									String both = reversed.concat(frown);
									System.out.println(both);
								}
							}
						</code></pre>
					</div>
					<aside class="notes">
						这篇论文提出了一个渐进的空指针检查
						它认为现有的处理方法引用太多的FP。
						为了减少这些FP，应该要对标记缺失进行乐观的处理。就是当标记缺失，我们不补上，也不去检查。
						如第一个例子：传递null作为参数，GNPA不会报错，它乐观地认为这个参数传递是有效的。
						第二个例子：对空指针解引用，GNPA也不报错，它乐观地认为reserved不是null，可以调用方法。
						但是显然这第二个例子是错误的，GNPA因此在动态运行中添加检查，在动态检查中会发现第13行的错误。
						把静态检查和动态检查综合来看，就能既减少FP，又能保证sound。

						jvm自己就会检查空指针解引用（本身在第13行就会报错），要你这个动态检查有什么用？
						1. 它的这个工具/方法不只针对java，也可用于c++等。在c++里面就没有空指针检查。
						2. 动态检查不只是针对解引用，还有对标记的检查
						3. 后面的结果显示：这个工具能够避免jvm一半以上的空指针检查。

						疑问：这个动态检查在遇到空指针解引用也是报错，简而言之程序依然会crash。这也能叫sound？那jvm是不是也是sound的？
					</aside>
				</section>
				<section>
					<h2>PICL: A Procedural Imperative Core Language</h2>
					<ul>
						<li>一种对编程语言的抽象</li>
						
					</ul>
					<img src="assets/PICL.png">
					<aside class="notes">
						把不同编程语言与空指针相关的部分抽取出来。GPNA因此不是针对特定语言的分析工具。
						解释一下重要的部分：
						标记有三种：nullable，nonnull，缺失（？）
						方法是带有标记的方法
						表达式只有：null，变量，对象的域，创建对象，方法调用，还有逻辑与、逻辑或，用来产生复杂的条件表达式
						判断条件只有：判断变量是不是null，结合上面的与或可以判断复杂条件
						语句只保留赋值、store、条件和循环、返回
					</aside>
				</section>
				<section>
					<h2>Control Flow Graph</h2>
					<img src="assets/CFG0.png">
					<img src="assets/CFG1.png">
					<aside class="notes">
						上面说的是抽象编程语言的语法，这里说的控制流图里面的指令。
						这里我看到，它的方法调用和方法入口处都带上标记。
						然后分支变成了branch、if、else三条指令。branch是真正用来对x做判断的，只判断是不是null。
						if表示x != null的分支，else表示== null的分支。这条指令用来帮助静态分析工具进行推断的。
						然后有对变量进行的与或操作的指令，根据y和z是不是null来决定x是不是null，用来实现复杂条件判断。
					</aside>
				</section>
				<section>
					<h2>Dynamic Semantics</h2>
					<ul>
						<li>对程序（PICL）动态行为的建模</li>
						<li>主要用于后面形式化的证明</li>
						
					</ul>
					<div class="r-stack">
						<img src="assets/Dynamic Program State.png">
						<img src="assets/Dynamic Heap.png">
						<img src="assets/Dynamic Stack.png">

					</div>
					<aside class="notes">
						程序状态=堆+栈
						堆是由地址到对象的映射，对象就是一堆成员变量及其取值
						栈由一个个帧组成，每个帧就是变量及其取值，再加上当前执行的代码。除了栈顶的帧，其他帧应该都停在了方法调用的那条代码上。

						程序运行的规则: 根据当前程序状态决定下一个程序状态。
						比方说当前是赋值指令，下一个程序状态就是让x映射到新的值上面。
						当前是if语句，那程序状态不变，if语句不干事。

						实际上一般的语句都能根据规则畅行无阻，就三种会可能卡住：方法调用，方法返回，解引用。
					</aside>
				</section>
				<section>
					<h2>A Static Null-Pointer Analysis for PICL</h2>
					<ul>
						<li>我们先形式化静态分析的过程</li>
						<li>且假设所有标记都打上了，也就是没有“?”的情况</li>
						<li>我们将证明在这种情况下静态分析是sound的</li>
					</ul>
				</section>
				<section>
					<h2>Semilattice of Abstract Values</h2>
					<ul>
						<li>静态检查的方法是数据流分析</li>
						<li>数据流是每个变量有三种状态：Nullable，Null，Nonnull</li>
						<li>具体化函数（concretization function）：三种状态所代表的具体取值范围
							<ul>
								<li>conc(Nullable) = Val, conc(Null) = {0}, conc(NonNull) = Val \ {0}</li>
							</ul></li>
					</ul>
					<img src="assets/semilattice.png">
					<aside class="notes">
						根据这个半格，当x是nonnull和x是null两个数据流值汇聚的时候，meet的结果是x是nullable。
					</aside>
				</section>
				<section>
					<h2>Transfer Function</h2>
					<img src="assets/transfer function.png" class="stretch">
					<aside class="notes">
						挑重点的讲：
						1. if x：这是当x != null的分支，因此x的状态是null
						2. x := m@a(y@b)，在调用函数后，x的状态就是是标记
						3. proc m@a(y@b)，在函数入口处，参数的状态就是标记
						4. null，new
						5. x := y.f，取对象的成员，因为f没有标记，我们无法判断f的状态，所以x只能保守推断为nullable。
							至于y = nonnull？我估计是因为防止出现冗余的报错。假如y是null，那么只会在这条指令报错，因为后面y变成nonnull了。
						6. x.f := y同理
					</aside>
				</section>
				<section>
					<h2>Fixpoint Algorithm</h2>
					<img src="assets/Fix point algorithm.png">

				</section>
				<section>
					<h2>Static Warnings</h2>
					<ul>
						<li>安全函数(safe function)：用来检查数据流值是否满足指令要求的状态，不然就报错</li>
						<img src="assets/safe.png">
						<li>σ(x) ⊑ safe(x)</li>
					</ul>
					<aside class="notes">
						在这里进行检查和报错。
						实际上就只是要求调用方法时参数的状态需要满足标记，返回的时候需要满足返回值的标记，以及解引用时指针不能为null。
						若数据流值中的状态小于safe函数才视为合法的正确的，比如数据流里面是null，safe的结果是nullable，那么就正确。
					</aside>
				</section>
				<section>
					<h2> Soundness of NPA</h2>
					<img src="assets/NPA soundness.png">
					<aside class="notes">
						这篇论文证明了两个命题：
						1. 假如运行的某个程序状态都满足数据流值中的状态（nullable，nonnull，null），那么程序会继续执行。
						2. 程序继续执行后的程序状态依然满足数据流值中的状态。
						因此程序不会中断，NPA是sound的
					</aside>
				</section>
				<section>
					<h2>Gradual Null-Pointer Analysis</h2>
					<ul>
						<li>考虑缺失标记的情况，对原来NPA进行改造</li>
						<li>数据流值</li>
						<li>半格</li>
						<li>序：定义“⊑”；不是偏序；主要用于safe函数（也就是检查）</li>

						
						<div class="r-stack stretch">
							<img src="assets/ABST~.png" class="fragment fade-in-then-out">
							<img src="assets/lattice~.png" class="fragment fade-in-then-out">
							<img src="assets/order！.png" class="fragment">
						</div>
					</ul>
					<aside class="notes">
						数据流值除了引入？一种状态，还添加了null？、nonnull？
						？的含义是，x可能为null，nonnull，nullable
						null？的含义是x可能为nullale或者null
						nonnull？的含义是x可能为nullable或者nonnull
						
						接着,我们接着对格进行改造.论文里面定义了新的状态之间的join运算,比较复杂
						我们还是直接看最终半格结构是什么样子

						然后重新定义状态之间的序，也就是小于关系。
						值得注意的是，这不是偏序，也不满足反对称。？小于任何值，任何值也小于？。
						半格和这个序是无关的，是独立的。
						半格在数据流分析用。这个序在检查报错的时候用。
						
					</aside>
				</section>
				<section>
					<h2>Gradual Null-Pointer Analysis</h2>
					<ul>
						<li class="fragment">传递函数</li>
						<li class="fragment">safe function</li>
						<li>不动点算法不变</li>
						<li>设计思路?</li>
					</ul>
					<div class="r-stack stretch">
						<img src="assets/flow function~.png">
						<img src="assets/safe function~.png"> 
						<img src="assets/reference.png">
					</div>
					<aside class="notes">
						传递函数和安全函数<br>
						这里写得很复杂，但是实际含义和前面的静态分析是一样的。就是标记是什么，变量的状态就是什么。只不过现在的标记多了“？”。<br>
						比如说对于方法调用，这个传递函数的效果就是把z的的状态设为a，a可能是“？”<br>
						对于安全函数也一样，假如调用函数的时候参数的标记是？，那么对y的要求就是？
						
						至于为什么这么设计wo hai mei kan，比如半格为什么这么定义的？传递函数为什么写得这么复杂？论文说他们是跟着另外一篇论文设计的。
						而那篇论文我还没看。
					</aside>
				</section>
				<section>
					<h2>Dynamic Checking</h2>
					<ul>
						<li></li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
